{
    "solver.ResidualMemory.peakmem_residual": {
        "code": "class ResidualMemory:\n    def peakmem_residual(self, size):\n        if BEFORE:\n            res = solver.residual(\n                    self.grid, self.model, self.sfield, self.sfield.field*0)\n            norm = np.linalg.norm(res)\n        else:  # After, norm is included in residual.\n            res, norm = solver.residual(\n                    self.grid, self.model, self.sfield, self.sfield.field*0)\n\n    def setup(self, size):\n        self.grid, self.model, self.sfield = get_model(size)",
        "name": "solver.ResidualMemory.peakmem_residual",
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'small'",
                "'big'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "d6d1047280c2594ce892e36711aa095756f078d5f48d24e46529b1c584212096"
    },
    "solver.ResidualTime.time_residual": {
        "code": "class ResidualTime:\n    def time_residual(self, size):\n        if BEFORE:\n            res = solver.residual(\n                    self.grid, self.model, self.sfield, self.sfield.field*0)\n            norm = np.linalg.norm(res)\n        else:  # After, norm is included in residual.\n            res, norm = solver.residual(\n                    self.grid, self.model, self.sfield, self.sfield.field*0)\n\n    def setup(self, size):\n        self.grid, self.model, self.sfield = get_model(size)",
        "min_run_count": 2,
        "name": "solver.ResidualTime.time_residual",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'small'",
                "'big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7a8712d0b968ed0f68576d29b75b6f1af5ff5e9398c54bcb8c121647a4ef8be6",
        "warmup_time": -1
    },
    "solver.SmoothingMemory.peakmem_smoothing": {
        "code": "class SmoothingMemory:\n    def peakmem_smoothing(self, lr_dir, size):\n        efield = utils.Field(self.grid, self.sfield.field)\n        inp = (self.grid, self.model, self.sfield, efield, 2, lr_dir)\n        if BEFORE:\n            solver.smoothing(*inp)\n            res = solver.residual(self.grid, self.model, self.sfield, efield)\n            norm = np.linalg.norm(res)\n        else:  # After, residual is included in smoothing and norm in residual.\n            res, norm = solver.smoothing(*inp)\n\n    def setup(self, lr_dir, size):\n        self.grid, self.model, self.sfield = get_model(size)",
        "name": "solver.SmoothingMemory.peakmem_smoothing",
        "param_names": [
            "lr_dir",
            "size"
        ],
        "params": [
            [
                "0",
                "1",
                "2",
                "3"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "605b74ff8f943eea68219ec0dc3cc39672fc9891ec4b7de3fcd7941490d99ebc"
    },
    "solver.SmoothingTime.time_smoothing": {
        "code": "class SmoothingTime:\n    def time_smoothing(self, lr_dir, size):\n        efield = utils.Field(self.grid, self.sfield.field)\n        inp = (self.grid, self.model, self.sfield, efield, 2, lr_dir)\n        if BEFORE:\n            solver.smoothing(*inp)\n            res = solver.residual(self.grid, self.model, self.sfield, efield)\n            norm = np.linalg.norm(res)\n        else:  # After, residual is included in smoothing and norm in residual.\n            res, norm = solver.smoothing(*inp)\n\n    def setup(self, lr_dir, size):\n        self.grid, self.model, self.sfield = get_model(size)",
        "min_run_count": 2,
        "name": "solver.SmoothingTime.time_smoothing",
        "number": 0,
        "param_names": [
            "lr_dir",
            "size"
        ],
        "params": [
            [
                "0",
                "1",
                "2",
                "3"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a80734a711960a5ca9369ffd2732c3e3a730fb5b19e6849c6de68e79c744bc6f",
        "warmup_time": -1
    },
    "solver.SolverMemory.peakmem_solver": {
        "code": "class SolverMemory:\n    def peakmem_solver(self, sslsolver, anisotropy):\n        solver.solver(\n                grid=self.grid,\n                model=self.model,\n                sfield=self.sfield,\n                cycle='F',\n                sslsolver=sslsolver,\n                semicoarsening=True,\n                linerelaxation=True,\n                verb=VERB)\n\n    def setup(self, sslsolver, anisotropy):\n        self.grid, self.model, self.sfield = get_model('small', anisotropy)",
        "name": "solver.SolverMemory.peakmem_solver",
        "param_names": [
            "sslsolver",
            "anisotropy"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "'iso'",
                "'vti'",
                "'tri'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "74fdf43a3648f62eeb630e8c4c3d84f7868c8b5de5121660a66ce322018beb3d"
    },
    "solver.SolverTimeCycle.time_solver": {
        "code": "class SolverTimeCycle:\n    def time_solver(self, cycle):\n        solver.solver(\n                grid=self.grid,\n                model=self.model,\n                sfield=self.sfield,\n                cycle=cycle,\n                sslsolver=False,\n                semicoarsening=True,\n                linerelaxation=True,\n                verb=VERB)\n\n    def setup(self, cycle):\n        self.grid, self.model, self.sfield = get_model('small')",
        "min_run_count": 2,
        "name": "solver.SolverTimeCycle.time_solver",
        "number": 0,
        "param_names": [
            "cycle"
        ],
        "params": [
            [
                "'V'",
                "'W'",
                "'F'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a4e7bd69b772ccb09b72c5a600b351e560079ee36c0167cddd8e23a0f0d6836a",
        "warmup_time": -1
    },
    "solver.SolverTimeMG.time_solver": {
        "code": "class SolverTimeMG:\n    def time_solver(self, semicoarsening, linerelaxation):\n        solver.solver(\n                grid=self.grid,\n                model=self.model,\n                sfield=self.sfield,\n                cycle='F',\n                sslsolver=False,\n                semicoarsening=semicoarsening,\n                linerelaxation=linerelaxation,\n                verb=VERB)\n\n    def setup(self, semicoarsening, linerelaxation):\n        self.grid, self.model, self.sfield = get_model('small')",
        "min_run_count": 2,
        "name": "solver.SolverTimeMG.time_solver",
        "number": 0,
        "param_names": [
            "semicoarsening",
            "linerelaxation"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "06abe37973c976126ab365deb92dcfb0e9bf8b20d3ee1e391b5e93446f0cb01e",
        "warmup_time": -1
    },
    "solver.SolverTimeSSL.time_solver": {
        "code": "class SolverTimeSSL:\n    def time_solver(self, sslsolver):\n        solver.solver(\n                grid=self.grid,\n                model=self.model,\n                sfield=self.sfield,\n                cycle='F',\n                sslsolver=sslsolver,\n                semicoarsening=True,\n                linerelaxation=True,\n                verb=VERB)\n\n    def setup(self, sslsolver):\n        self.grid, self.model, self.sfield = get_model('small')",
        "min_run_count": 2,
        "name": "solver.SolverTimeSSL.time_solver",
        "number": 0,
        "param_names": [
            "sslsolver"
        ],
        "params": [
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "79dac8b98ddf321a448c48562641a2f07c652de91f31cab9f067ebae6784f5e6",
        "warmup_time": -1
    },
    "version": 2
}